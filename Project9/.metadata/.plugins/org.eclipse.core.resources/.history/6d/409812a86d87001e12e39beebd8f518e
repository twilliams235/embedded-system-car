/*
 * buffer.c
 *
 *  Created on: Nov 17, 2023
 *      Author: tylerwilliams
 */

#include  "msp430.h"
#include  <string.h>
#include  "Compiled/functions.h"
#include  "Compiled/LCD.h"
#include  "Compiled/ports.h"
#include  "Compiled/macros.h"
#include  "Compiled/timers.h"



extern unsigned int displayflag1;
extern unsigned int displayflag0;
extern unsigned int fram_only;
extern unsigned int iot_rx_rd;
extern unsigned int iot_tx;
extern unsigned int usb_rx_rd;
extern unsigned int usb_pb_index; // Index for process_buffer
extern unsigned int iot_pb_index;
extern volatile char IOT_Ring_Rx[SMALL_RING_SIZE];
extern volatile char IOT_Process_Tx[SMALL_RING_SIZE];
extern volatile char USB_Ring_Rx[SMALL_RING_SIZE];
extern volatile char USB_Process_Tx[SMALL_RING_SIZE];
extern unsigned int iot_rx_wr;
extern unsigned int usb_rx_wr;
extern volatile unsigned char display_changed;
extern volatile unsigned char update_display;
extern char display_line[4][11];

unsigned int ch;
unsigned char command;
unsigned int iot_flag;

//IOT Process ================================================
unsigned int line;
unsigned int nextline;
volatile char IOT_Data[4][SMALL_RING_SIZE];
unsigned int character;
unsigned int test_Value;
unsigned int IOT_parse;
unsigned int boot_state;
unsigned int ip_address_found;
unsigned int iot_index;
unsigned int dot_count;
unsigned int ip_count;
unsigned int counter;
unsigned int ssid;
char ip_mac[SMALL_RING_SIZE];
char AT[SMALL_RING_SIZE];
char ip_address[SMALL_RING_SIZE];







void process_UCA0(void);
void process_UCA1(void);
void handle_fram(void);
void USCI_A0_transmit(void);
void USCI_A1_transmit(void);
void IOT_Process(void);


//ring -> process for UCA1_1
void process_UCA1(void) {
    if(displayflag1 == TRUE) {
        displayflag1 = FALSE;
        while(usb_rx_rd != usb_rx_wr) {
            USB_Process_Tx[usb_pb_index] = USB_Ring_Rx[usb_rx_rd];
            if(USB_Process_Tx[usb_pb_index]== '\n') {
                usb_rx_rd++;
                usb_pb_index = 0;
                //r1 = 0;
                if(usb_rx_rd >= sizeof(USB_Ring_Rx)) {
                    usb_rx_rd = 0;
                }
                break;
            }
            usb_rx_rd++;
            if(usb_rx_rd >= sizeof(USB_Ring_Rx)) {
                usb_rx_rd = 0;
            }
            usb_pb_index++;
            if(usb_pb_index >= sizeof(USB_Process_Tx)) {
                usb_pb_index = 0;
                //r1++;
            }
        }
        if(fram_only == FALSE) {
            USCI_A0_transmit();
        }
        else {
            fram_only = FALSE;
            handle_fram();
        }
    }
}




//ring -> process for UCA0
void process_UCA0(void) {
    if(displayflag0 == TRUE) {
          displayflag0 = FALSE;
          while(iot_rx_rd != iot_rx_wr) {
              IOT_Process_Tx[iot_pb_index] = IOT_Ring_Rx[iot_rx_rd];
              if(IOT_Process_Tx[iot_pb_index]== '\n') {
                  iot_rx_rd++;
                  iot_pb_index = 0;
                  //r0 = 0;
                  if(iot_rx_rd >= sizeof(IOT_Ring_Rx)) {
                      iot_rx_rd = 0;
                  }
                  break;
              }
              iot_rx_rd++;
              if(iot_rx_rd >= sizeof(IOT_Ring_Rx)) {
                  iot_rx_rd = 0;
              }
              iot_pb_index++;
              if(iot_pb_index >= sizeof(IOT_Process_Tx)) {
                  iot_pb_index = 0;
                  //r0++;
              }
          }
          USCI_A1_transmit();
    }
}


void handle_fram(void) {
    ch = 0;
    command = USB_Process_Tx[ch];
    while(command != '^') {
        ch++;
        command = USB_Process_Tx[ch];
    }
    ch++;
    command = USB_Process_Tx[ch];
    switch(command) {
    case SLOWBAUD:
        strcpy(display_line[2], "  9,600   ");
        display_changed = TRUE;
        update_display = TRUE;
        UCA0MCTLW = 0x4911; //9,600 baud
        UCA0BRW = 52; // 9,600 baud
        break;
    case FASTBAUD:
        strcpy(display_line[2], " 115,200  ");
        display_changed = TRUE;
        update_display = TRUE;
        UCA1MCTLW = 0x5551; //115,200 baud
        UCA1BRW = 4; // 115,200 baud
        break;
    case ENABLEIOT:
        P3OUT |= IOT_EN;
        P3OUT &= ~IOT_EN;
        iot_flag = HIGH;
        strcpy(display_line[2], " ENABLING ");
        display_changed = TRUE;
        update_display = TRUE;
    default:
        break;
    }
}



void IOT_Process(void){ // Process IOT messages
    int i;
    unsigned int iot_rx_wr_temp;
    iot_rx_wr_temp = iot_rx_wr;
    if(iot_rx_wr_temp != iot_rx_rd){ // Determine if IOT is available
        IOT_Data[line][character] = IOT_Ring_Rx[iot_rx_rd++];
        if(iot_rx_rd >= sizeof(IOT_Ring_Rx)){
            iot_rx_rd = BEGINNING;
        }

        if(IOT_Data[line][character] == 0x0A){
            character = 0;
            line++;
            if(line >= 4){
                line = 0;
            }
            nextline = line + 1;
            if(nextline >= 4){
                nextline = 0;
            }
        }else{
            switch(character){
            case 0:
                if(IOT_Data[line][character] == '+'){ // Got "+"
                    test_Value++;
                    if(test_Value){
                        RED_LED_ON;
                    }
                    IOT_parse = 1;
                }
                break;
             case 1:
                 // GRN_LED_ON;
                 break;
             case 3:
                 if(IOT_Data[line][character] == 'J'){ // Got ssid
                     ssid = 8;
                     for(i = 0; i < 10; i++) {
                         if(IOT_Data[line][ssid] == '"') {
                             break;
                         }
                         display_line[0][i] = IOT_Data[line][ssid];
                         ssid++;
                     }
                     display_changed = TRUE;
                     update_display = TRUE;
                 }
                 break;
             case 4:
                 if(IOT_Data[line][character] == 'y'){ // Got read"y"
                     for(i=0; i<sizeof(AT); i++){
                         USB_Process_Tx[i] = AT[i];
                     }
                     UCA0IE |= UCTXIE;
                     boot_state = 1;
                     // RED_LED_ON;
                     GRN_LED_OFF;
                 }
                 break;
             case 5:
                 if(IOT_Data[line][character] == 'G'){ // Got IP
                     for(i=0; i<sizeof(ip_mac); i++){
                         USB_Process_Tx[i] = ip_mac[i];
                     }
                     iot_tx = 0;
                     UCA0IE |= UCTXIE;
                 }
                 break;
              case 6:
                  break;
              case 10:
                  if(IOT_Data[line][character] == 'I'){
                      ip_address_found = 1;
                      dot_count = 0;
                      ip_count = 14;
                      counter = 0;
                      strcpy(display_line[1], "IP Address");
                      while(dot_count < 2) {
                          display_line[2][counter] = IOT_Data[line][ip_count];
                          if(IOT_Data[line][ip_count] == '.') {
                              dot_count++;
                          }
                          counter++;
                          ip_count++;
                      }
                      dot_count = 0;
                      counter = 0;
                      while(dot_count < 2) {
                          display_line[3][counter] = IOT_Data[line][ip_count];
                          if(IOT_Data[line][ip_count] == '.') {
                              dot_count++;
                          }
                          counter++;
                          ip_count++;
                      }
//                      for(i=0; i<sizeof(ip_address); i++){
//                          ip_address[i] = 0;
//                      }
                      display_changed = TRUE;
                      update_display = TRUE;
                      iot_index = 0;
                  }
                  break;
              default: break;
              }
        }
    }
}




