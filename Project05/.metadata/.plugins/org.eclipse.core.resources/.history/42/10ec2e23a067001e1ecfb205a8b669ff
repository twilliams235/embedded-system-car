//------------------------------------------------------------------------------
//
//  Description: This file contains the System Configurations
//
//  Jim Carlson
//  Sept 2023
//  Built with Code Composer Version: CCS12.4.0.00007_win64
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
#include  "msp430.h"
#include  <string.h>
#include  "functions.h"
#include  "LCD.h"
#include  "ports.h"
#include  "macros.h"
#include  "timers.h"

unsigned int dec_sec;
extern volatile unsigned char update_display;
extern volatile unsigned char display_changed;
extern char display_line[4][11];
//volatile unsigned int debounce_count1;
//volatile unsigned int debounce_count2;
//volatile unsigned int debounce_event_in_progress1;
//volatile unsigned int debounce_event_in_progress2;
extern unsigned int step;
char event;
extern unsigned int dec_sec;
extern unsigned int second;

void enable_interrupts(void);

//------------------------------------------------------------------------------
// System Configurations

// Tells the compiler to provide the value in reg as an input to an
// in line assembly block.  Even though the block contains no instructions,
// the compiler may not optimize it away, and is told that the value
// may change and should not be relied upon.

//in line void READ_AND_DISCARD(unsigned int reg) __attribute__((always_inline));
//void READ_AND_DISCARD(unsigned int reg){
//  asm volatile ("" : "=m" (reg) : "r" (reg));
//}

//in line void enable_interrupts(void) __attribute__((always_inline));
void enable_interrupts(void){
  __bis_SR_register(GIE);     // enable interrupts
//  asm volatile ("eint \n");
}

//inline void disable_interrupts(void) __attribute__((always_inline));
//void disable_interrupts(void){
//  asm volatile ("dint \n");
//}


// TimerB0 0 Interrupt handler
#pragma vector = TIMER0_B0_VECTOR
__interrupt void Timer0_B0_ISR(void){
    switch(second){
    case 1:
        dec_sec++;
        if(dec_sec == 10) {
            dec_sec = 0;
            if(step == 0 || step == 4) {
                event = STOP1;
                step++;
            }
            else if(step == 1) {
                event = REV;
                step++;
            }
            else if(step == 3) {
                event = FOR;
                step++;
            }
            else if(step == 5) {
                event = SPINCW;
                step++;
            }
        }
        break;
    case 2:
        dec_sec++;
        if(dec_sec == 20) {
            dec_sec = 0;
            if(step == 2) {
                step++;
                event = STOP1;
            }
            else if(step == 7) {
                event = SPINCCW;
                step++;
            }

        }
        break;
    case 3:
        dec_sec++;
        if(dec_sec == 30) {
            dec_sec = 0;
            if(step == 6) {
                step++;
                event = STOP2;
            }
            else if(step == 8) {
                step++;
                event = STOP2;
            }
        }
        break;
    default: break;
    }

    TB0CCR0 += TB0CCR0_INTERVAL; // Add Offset to TBCCR0
}
